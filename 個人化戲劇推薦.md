
# 個人化戲劇推薦系統的建立

### 此檔案主要是利用「基於內容」推薦算法(CB)及「協同過濾」推薦算法(CF)，計算每個使用者對每部戲劇的個人喜好分數，再搭配三個推薦策略，得到「個人化+熱門度+最新流行」的推薦結果

## 1. 匯入需要的套件及各種資料


```python
import pandas as pd
import numpy as np
import math
import scipy
from scipy import spatial

tbl_DramaGenre=pd.read_csv('tbl_DramaGenre.csv', encoding='utf-8') #戲劇類型對照表
tbl_Genre=pd.read_csv('tbl_Genre.csv', encoding='utf-8')  #類型基本資料
tbl_Drama=pd.read_csv('tbl_Drama.csv', encoding='utf-8')  #戲劇基本資料
tbl_Actor=pd.read_csv('tbl_Actor.csv', encoding='utf-8')  #演員基本資料
tbl_DramaActor=pd.read_csv('tbl_DramaActor.csv', encoding='utf-8') #戲劇演員對照表
df_drama_ott=pd.read_csv('df_drama_ott.csv', encoding='utf-8') #戲劇OTT平台對照表
df_Drama_GenreName=pd.read_csv('df_Drama_GenreName.csv', encoding='utf-8') #戲劇類型對照表
random_result=pd.read_csv('random_result_5000_v3.csv', encoding='utf-8') #5000筆模擬資料
df_drama_zone_genre_actor_all=pd.read_csv('df_drama_zone_genre_actor_all2.csv', encoding='utf-8') #每部片的地區、類型、演員特徵
```

### 1.1 將5000筆模擬資料整理成dictionary格式，俾利後續CF(user-based)演算法的計算


```python
#5000筆使用者的看片資料包括ip、dramaID、收藏日期、收藏次數

random_result.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ipAddr</th>
      <th>dramaID</th>
      <th>dateTrans</th>
      <th>timesQuery</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>140.137.1.1</td>
      <td>G020111/G020101/G020021/G030273/G030015/G01014...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>140.137.1.2</td>
      <td>G010243/G010273/G010259/G030332/G030204/G03004...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>140.137.1.3</td>
      <td>G010212/G010177/G010210/G030308/G030134/G03029...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>140.137.1.4</td>
      <td>G010201/G010215/G010214/G030264/G030345/G03002...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>140.137.1.5</td>
      <td>G010007/G010204/G010075/G010049/G010169/G01000...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




```python
#將個人ip及dramaID的對應關係整理成dictionary形式

ip_history_list=list(random_result['ipAddr'].tolist())
ip_history_list[1:10]

draw_result_all_t={}

for i in ip_history_list:

    ll=random_result[random_result['ipAddr']==i]['dramaID'].tolist()
    ll[0].split("/")
    draw_result_all_t[i]=ll[0].split("/")
```

### 1.2 將新使用者的資料加入5000筆資料中，俾利後續CF(user-based)演算法的計算


```python
#取得新使用者的收藏片單並且整理成list

histroryDrama_list=[]
histroryDrama=[('127.0.0.1', 'G020073'), ('127.0.0.1', 'G010012'), ('127.0.0.1', 'G010003'), ('127.0.0.1', 'G010002'), \
              ('127.0.0.1', 'G010005'),('127.0.0.1', 'G010056'), ('127.0.0.1', 'G010169'), ('127.0.0.1', 'G020041') ]

for i in histroryDrama:
    histroryDrama_list.append(i[1])
```


```python
#將新的使用者的看片清單加入5000人的消費者使用清單中(單人不累積時使用)

draw_result_all_t['127.0.0.1']=histroryDrama_list
draw_result_all_t['127.0.0.1']

drama_dic_all={}

if '127.0.0.1' in ip_history_list:
    ip_history_list_new=ip_history_list
else:
    ip_history_list_new=ip_history_list+['127.0.0.1']

for i in ip_history_list_new:
    drama_dic1={}
    for j in draw_result_all_t[i]:
        drama_dic1[j]=1
        drama_dic_all[i]=drama_dic1
```


```python
#將新的使用者的看片清單加入5000人的消費者使用清單中(單人累積時使用)

# if '127.0.0.1' in ip_history_list:
#     draw_result_all_t['127.0.0.1']=draw_result_all_t['127.0.0.1']+histroryDrama_list
# else:
#     draw_result_all_t['127.0.0.1']=histroryDrama_list
    
# len(draw_result_all_t)
```

## 2. 「基於內容演算法」(Content-Based Recommendations)的計算

### 2.1 根據使用者的收藏片單資料，找出其對應的戲劇特徵


```python
df_drama_zone_genre_actor_ind=pd.DataFrame()

for i in draw_result_all_t['127.0.0.1']:
    df=df_drama_zone_genre_actor_all[df_drama_zone_genre_actor_all['dramaID']==i]
    df_drama_zone_genre_actor_ind=df_drama_zone_genre_actor_ind.append(df)

df_drama_zone_genre_actor_ind
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>dramaName</th>
      <th>韓國</th>
      <th>日本</th>
      <th>台灣</th>
      <th>奇幻</th>
      <th>傳記</th>
      <th>科幻</th>
      <th>星座</th>
      <th>驚悚</th>
      <th>推理</th>
      <th>...</th>
      <th>高英軒</th>
      <th>高雅星</th>
      <th>魏蔓</th>
      <th>黃健瑋</th>
      <th>黃姵嘉</th>
      <th>黃正音</th>
      <th>黃河</th>
      <th>黃瀞怡</th>
      <th>黃騰浩</th>
      <th>dramaID</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>682</th>
      <td>要在蒂凡尼吃早餐</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G020073</td>
    </tr>
    <tr>
      <th>73</th>
      <td>一把青</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010012</td>
    </tr>
    <tr>
      <th>576</th>
      <td>1989一念間</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010003</td>
    </tr>
    <tr>
      <th>296</th>
      <td>16個夏天</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010002</td>
    </tr>
    <tr>
      <th>215</th>
      <td>A咖的路</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010005</td>
    </tr>
    <tr>
      <th>206</th>
      <td>臺北歌手</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010056</td>
    </tr>
    <tr>
      <th>103</th>
      <td>美男魚澡堂</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010169</td>
    </tr>
    <tr>
      <th>11</th>
      <td>有家可歸的戀人</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G020041</td>
    </tr>
  </tbody>
</table>
<p>8 rows × 170 columns</p>
</div>



### 2.2 根據使用者的收藏片單資料，計算使用者對不同戲劇特徵的喜好度


```python
#首先從使用者收藏清單中，計算各個戲劇特徵的出現次數，並計算該次數佔總收藏片數的比重

df_ind=list(df_drama_zone_genre_actor_ind.mean(axis=0))[0:]

#針對每個戲劇特徵進行比重的調整

df_ind1=[]
for i in df_ind[0:3]:
    df_ind1.append(i/3) #降低地區特徵的重要性
for i in df_ind[3:15]:
     df_ind1.append(i)
for i in df_ind[15:16]:
    df_ind1.append(i/2) #降低戲劇類型中「劇情」的重要性
for i in df_ind[16:22]:
     df_ind1.append(i)
for i in df_ind[22:23]:
    df_ind1.append(i/2) #降低戲劇類型中「愛情」的重要性
for i in df_ind[23:168]:
    df_ind1.append(i)
```

### 2.3 根據每個人對不同戲劇特徵的喜好度，利用餘弦相似度計算使用者對不同戲劇的喜好程度


```python
dramaName_list=list(set(df_drama_zone_genre_actor_all['dramaID']))

grade_CB={}
for i in dramaName_list:
    if i in draw_result_all_t['127.0.0.1']:
        pass
    else:
        df_ind_drama=np.array(df_drama_zone_genre_actor_all[df_drama_zone_genre_actor_all['dramaID']==i]).tolist()
        df_ind_drama1=df_ind_drama[0][1:-1]
        sum_ab=0
        sum_a2=0
        sum_b2=0
        for j in range(0,168,1):
            sum_ab=sum_ab+df_ind_drama1[j]*df_ind1[j]
            sum_a2=sum_a2+(df_ind_drama1[j])**2
            sum_b2=sum_b2+(df_ind1[j])**2        
        grade_CB[i]=round(sum_ab/((sum_a2**0.5)*(sum_b2**0.5)),4)

grade_CB1=sorted(grade_CB.items(), key=lambda d: d[1], reverse=True)

CB={}
for i in grade_CB1:
    CB[i[0]]=i[1]

CB['G010075'] #根據CB演算法，使用者對G010075(dramaID)的可能評分
```




    0.5995



### 3.「協同過濾演算法」(User-baded CollaboratIve Filtering)的計算

### 3.1建立計算餘弦相似度的函數


```python
def consine(rating1, rating2):
    sum_xy=0
    sum_x2=0
    sum_y2=0
    n=0

    for key in rating1:
        if key in rating2:
            n=n+1
            x=rating1[key]
            y=rating2[key]
            sum_xy=sum_xy+x*y
            sum_x2=sum_x2+pow(x,2)
            sum_y2=sum_y2+pow(y,2)
    if n==0:
        return 0
    
    denominator=(math.sqrt(sum_x2))*(math.sqrt(sum_y2))
    if denominator==0:
        return 0
    else:
        return (sum_xy/denominator) 
```

### 3.2建立計算倆倆使用者相似度的函數並進行排序


```python
def NearestNeighbor(user_ip, data):
    distances=[]
    for instance_ip in data:
        if instance_ip != user_ip:
            distance = consine(data[user_ip], data[instance_ip])
            distances.append((instance_ip, distance))
    distances.sort(key=lambda artistTuple:artistTuple[1], reverse=True)
    return distances
```

### 3.3找出相似度最高的前10位使用者，並根據這些使用者的收藏清單計算特定使用者對其未收藏戲劇的喜好程度


```python
def recommend(user_ip, data):
    recommendations={}
    nearest=NearestNeighbor(user_ip, data)
    userRatings=data[user_ip]
    totalDistance=0.0000
    for i in range(10):
        totalDistance=totalDistance+nearest[i][1]
    for i in range(10):
        weight = nearest[i][1]/totalDistance
        name = nearest[i][0]
        neighborRatings = data[name]
        for drama in neighborRatings:
            if not drama in userRatings:
                if drama not in recommendations:
                    recommendations[drama] = round((neighborRatings[drama]*weight),4)
                else:
                    recommendations[drama] = round((recommendations[drama]+neighborRatings[drama]*weight),4)
    recommendations = list(recommendations.items())
    recommendations.sort(key=lambda artistTuple: artistTuple[1], reverse = True)
    return recommendations 
```

### 3.4針對特定使用者，利用前述公式計算出該使用者對其未收藏戲劇的喜好分數


```python
data=drama_dic_all
grade_CF=recommend('127.0.0.1', data)

CF={}
for i in grade_CF:
    CF[i[0]]=i[1]
    
CF['G010075'] #根據CF演算法，使用者對G010075(dramaID)的可能評分
```




    0.4



## 4. 對CB及CF得到的分數進行加權平均，得到每個使用者的個人喜好分數


```python
mix={}

for key in CB:
    try:
        mix[key]=(CB[key]+CF[key]) 
    except:
        mix[key]=CB[key]

r_mix=sorted(mix.items(), key=lambda x:-x[1])

r_mix_dic={}

for i in r_mix:
    r_mix_dic[i[0]]=i[1]

r_mix_dic['G010075'] #CB及CF加權後， 使用者對G010075(dramaID)的喜好分數
```




    0.9995



## 5. 利用個人喜好分數，搭配三種推薦策略，建構推薦清單

### 5.1 推薦策略一：利用使用者收藏清單判斷其偏好戲劇類型，將這些類型的戲劇抽取出來，利用個人喜好分數進行排序


```python
# 利用使用者過去的收藏清單判斷其偏好的戲劇類型

index_list=list(df_drama_zone_genre_actor_ind.mean(axis=0).index)[3:28]
grade_list=list(df_drama_zone_genre_actor_ind.mean(axis=0))[3:28]
ind_preference={}
for i in range(len(index_list)):
    ind_preference[index_list[i]]=grade_list[i]
genre_prefer=sorted(ind_preference.items(), key=lambda d: d[1], reverse=True)
genre_prefer[0:5]
```




    [('劇情', 1.0), ('喜劇', 0.25), ('奇幻', 0.125), ('歷史', 0.125), ('家庭', 0.125)]




```python
#將這些類型的戲劇抽取出來

df_Drama_prefer=df_Drama_GenreName[(df_Drama_GenreName['genreName']==genre_prefer[0][0]) \
                                   | (df_Drama_GenreName['genreName']==genre_prefer[1][0])\
                                   | (df_Drama_GenreName['genreName']==genre_prefer[2][0])\
                                   | (df_Drama_GenreName['genreName']==genre_prefer[3][0])]

df_Drama_prefer_list=df_Drama_prefer['dramaID'].tolist()
df_Drama_prefer_list[0:10]
```




    ['G010002',
     'G010003',
     'G010004',
     'G010005',
     'G010006',
     'G010007',
     'G010011',
     'G010012',
     'G010013',
     'G010015']




```python
#利用個人喜好分數進行排序, 但排除使用者已經收藏的戲劇

personal_rec={}
for i in df_Drama_prefer_list:
    try:
        personal_rec[i]=r_mix_dic[i]        
    except:
        pass
    
personal_rec1=sorted(personal_rec.items(), key=lambda x:-x[1])

drama_list_exclude=df_drama_zone_genre_actor_ind['dramaID'].tolist()

personal_rec1_list=[]
for i in personal_rec1:
    if i[0] in drama_list_exclude:
        pass
    else:
        personal_rec1_list.append(i[0])

personal_rec1_list[0:3]
```




    ['G010075', 'G010007', 'G010049']



### 5.2 推薦策略二：利用豆辨評分找出前100部評分最高的戲劇，將這些戲劇抽取出來，利用個人喜好分數進行排序


```python
#利用豆辨評分找出前100部評分最高的戲劇

pop=tbl_Drama.sort_values('hitto', ascending=False).head(100)
df_pop_prefer_list=pop['dramaID'].tolist()
df_pop_prefer_list[0:10]
```




    ['G010032',
     'G010033',
     'G030312',
     'G030167',
     'G030160',
     'G010152',
     'G020016',
     'G010012',
     'G020086',
     'G010234']




```python
#利用個人喜好分數進行排序, 但排除使用者已經收藏或是已出現在「推薦策略一」的戲劇

pop_rec={}
for i in df_pop_prefer_list:
    try:
        pop_rec[i]=r_mix_dic[i]        
    except:
        pass

pop_rec1=sorted(pop_rec.items(), key=lambda x:-x[1])

pop_rec1_list=[]
for i in pop_rec1:
    if i[0] in personal_rec1_list[0:4]+drama_list_exclude:
        pass
    else:
        pop_rec1_list.append(i[0])

pop_rec1_list[0:3]
```




    ['G010166', 'G010221', 'G010008']



### 5.3 推薦策略三：找出近6個月出版的新劇，將這些戲劇抽取出來，利用個人喜好分數進行排序


```python
#找出近6個月出版的新劇

latest=tbl_Drama.sort_values('publishTime', ascending=False).head(60)
df_latest_prefer_list=latest['dramaID'].tolist()
df_latest_prefer_list[0:10]
```




    ['G030096',
     'G030355',
     'G030353',
     'G030183',
     'G010169',
     'G010306',
     'G020128',
     'G030357',
     'G020131',
     'G030358']




```python
#利用個人喜好分數進行排序, 但排除使用者已經收藏或是已出現在「推薦策略一」及「推薦策略二」的戲劇

latest_rec={}
for i in df_latest_prefer_list:
    try:
        latest_rec[i]=r_mix_dic[i]        
    except:
        pass

latest_rec1=sorted(latest_rec.items(), key=lambda x:-x[1])

latest_rec1_list=[]
for i in latest_rec1:
    if i[0] in personal_rec1_list[0:4]+pop_rec1_list[0:4]+drama_list_exclude:
        pass
    else:
        latest_rec1_list.append(i[0])

latest_rec1_list[0:3]
```




    ['G010308', 'G010306', 'G010125']



### 5.4 推薦清單


```python
print(personal_rec1_list[0:4])
print(pop_rec1_list[0:4])
print(latest_rec1_list[0:4])
```

    ['G010075', 'G010007', 'G010049', 'G010293']
    ['G010166', 'G010221', 'G010008', 'G010239']
    ['G010308', 'G010306', 'G010125', 'G010307']
    
