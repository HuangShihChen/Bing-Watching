
# 個人化戲劇推薦系統的建立

### 此檔案主要是利用「基於內容」推薦算法(CB)及「協同過濾」推薦算法(CF)，計算每個使用者對每部戲劇的個人喜好分數，再搭配三個推薦策略，得到「個人化+熱門度+最新流行」的推薦結果

## 1. 匯入需要的套件及各種資料


```python
import pandas as pd
import numpy as np
import math
import scipy
import sys
from scipy import spatial
from collections import Counter
from operator import itemgetter
from collections import defaultdict

tbl_DramaGenre=pd.read_csv('tbl_DramaGenre.csv', encoding='utf-8') #戲劇類型對照表
tbl_Genre=pd.read_csv('tbl_Genre.csv', encoding='utf-8')  #類型基本資料
tbl_Drama=pd.read_csv('tbl_Drama.csv', encoding='utf-8')  #戲劇基本資料
tbl_Actor=pd.read_csv('tbl_Actor.csv', encoding='utf-8')  #演員基本資料
tbl_DramaActor=pd.read_csv('tbl_DramaActor.csv', encoding='utf-8') #戲劇演員對照表
df_drama_ott=pd.read_csv('df_drama_ott.csv', encoding='utf-8') #戲劇OTT平台對照表
df_Drama_GenreName=pd.read_csv('df_Drama_GenreName.csv', encoding='utf-8') #戲劇類型對照表
random_result=pd.read_csv('random_result_5000_v3.csv', encoding='utf-8') #5000筆模擬資料
df_drama_zone_genre_actor_all=pd.read_csv('df_drama_zone_genre_actor_all2.csv', encoding='utf-8') #每部片的地區、類型、演員特徵
```

### 1.1 將5000筆模擬資料整理成dictionary格式，俾利後續CF(user-based)演算法的計算


```python
#5000筆使用者的看片資料包括ip、dramaID、收藏日期、收藏次數

random_result.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ipAddr</th>
      <th>dramaID</th>
      <th>dateTrans</th>
      <th>timesQuery</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>140.137.1.1</td>
      <td>G020111/G020101/G020021/G030273/G030015/G01014...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>140.137.1.2</td>
      <td>G010243/G010273/G010259/G030332/G030204/G03004...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>140.137.1.3</td>
      <td>G010212/G010177/G010210/G030308/G030134/G03029...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>140.137.1.4</td>
      <td>G010201/G010215/G010214/G030264/G030345/G03002...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>140.137.1.5</td>
      <td>G010007/G010204/G010075/G010049/G010169/G01000...</td>
      <td>2018/08/13</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




```python
#將個人ip及dramaID的對應關係整理成dictionary形式

ip_history_list=list(random_result['ipAddr'].tolist())
ip_history_list[1:10]

draw_result_all_t={}

for i in ip_history_list:

    ll=random_result[random_result['ipAddr']==i]['dramaID'].tolist()
    ll[0].split("/")
    draw_result_all_t[i]=ll[0].split("/")
```

### 1.2 將新使用者的資料加入5000筆資料中，俾利後續CF(user-based)演算法的計算


```python
#取得新使用者的收藏片單並且整理成list

histroryDrama_list=[]
histroryDrama=[('127.0.0.1', 'G020073'), ('127.0.0.1', 'G010012'), ('127.0.0.1', 'G010003'), ('127.0.0.1', 'G010002'), \
              ('127.0.0.1', 'G010005'),('127.0.0.1', 'G010056'), ('127.0.0.1', 'G010169'), ('127.0.0.1', 'G020041') ]

for i in histroryDrama:
    histroryDrama_list.append(i[1])
```


```python
#將新的使用者的看片清單加入5000人的消費者使用清單中(單人不累積時使用)

draw_result_all_t['127.0.0.1']=histroryDrama_list
draw_result_all_t['127.0.0.1']

drama_dic_all={}

if '127.0.0.1' in ip_history_list:
    ip_history_list_new=ip_history_list
else:
    ip_history_list_new=ip_history_list+['127.0.0.1']

for i in ip_history_list_new:
    drama_dic1={}
    for j in draw_result_all_t[i]:
        drama_dic1[j]=1
        drama_dic_all[i]=drama_dic1
```


```python
#將新的使用者的看片清單加入5000人的消費者使用清單中(單人累積時使用)

# if '127.0.0.1' in ip_history_list:
#     draw_result_all_t['127.0.0.1']=draw_result_all_t['127.0.0.1']+histroryDrama_list
# else:
#     draw_result_all_t['127.0.0.1']=histroryDrama_list
    
# len(draw_result_all_t)
```

## 2. 「基於內容演算法」(Content-Based Recommendations)的計算

### 2.1 根據使用者的收藏片單資料，找出其對應的戲劇特徵


```python
df_drama_zone_genre_actor_ind=pd.DataFrame()

for i in draw_result_all_t['127.0.0.1']:
    df=df_drama_zone_genre_actor_all[df_drama_zone_genre_actor_all['dramaID']==i]
    df_drama_zone_genre_actor_ind=df_drama_zone_genre_actor_ind.append(df)

df_drama_zone_genre_actor_ind
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>dramaName</th>
      <th>韓國</th>
      <th>日本</th>
      <th>台灣</th>
      <th>奇幻</th>
      <th>傳記</th>
      <th>科幻</th>
      <th>星座</th>
      <th>驚悚</th>
      <th>推理</th>
      <th>...</th>
      <th>高英軒</th>
      <th>高雅星</th>
      <th>魏蔓</th>
      <th>黃健瑋</th>
      <th>黃姵嘉</th>
      <th>黃正音</th>
      <th>黃河</th>
      <th>黃瀞怡</th>
      <th>黃騰浩</th>
      <th>dramaID</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>682</th>
      <td>要在蒂凡尼吃早餐</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G020073</td>
    </tr>
    <tr>
      <th>73</th>
      <td>一把青</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010012</td>
    </tr>
    <tr>
      <th>576</th>
      <td>1989一念間</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010003</td>
    </tr>
    <tr>
      <th>296</th>
      <td>16個夏天</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010002</td>
    </tr>
    <tr>
      <th>215</th>
      <td>A咖的路</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010005</td>
    </tr>
    <tr>
      <th>206</th>
      <td>臺北歌手</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010056</td>
    </tr>
    <tr>
      <th>103</th>
      <td>美男魚澡堂</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G010169</td>
    </tr>
    <tr>
      <th>11</th>
      <td>有家可歸的戀人</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>G020041</td>
    </tr>
  </tbody>
</table>
<p>8 rows × 170 columns</p>
</div>



### 2.2 根據使用者的收藏片單資料，計算使用者對不同戲劇特徵的喜好度


```python
#首先從使用者收藏清單中，計算各個戲劇特徵的出現次數，並計算該次數佔總收藏片數的比重

df_ind=list(df_drama_zone_genre_actor_ind.mean(axis=0))[0:]

#針對每個戲劇特徵進行比重的調整

df_ind1=[]
for i in df_ind[0:3]:
    df_ind1.append(i/3) #降低地區特徵的重要性
for i in df_ind[3:15]:
     df_ind1.append(i)
for i in df_ind[15:16]:
    df_ind1.append(i/2) #降低戲劇類型中「劇情」的重要性
for i in df_ind[16:22]:
     df_ind1.append(i)
for i in df_ind[22:23]:
    df_ind1.append(i/2) #降低戲劇類型中「愛情」的重要性
for i in df_ind[23:168]:
    df_ind1.append(i)
```

### 2.3 根據每個人對不同戲劇特徵的喜好度，利用餘弦相似度計算使用者對不同戲劇的喜好程度


```python
dramaName_list=list(set(df_drama_zone_genre_actor_all['dramaID']))

grade_CB={}
for i in dramaName_list:
    if i in draw_result_all_t['127.0.0.1']:
        pass
    else:
        df_ind_drama=np.array(df_drama_zone_genre_actor_all[df_drama_zone_genre_actor_all['dramaID']==i]).tolist()
        df_ind_drama1=df_ind_drama[0][1:-1]
        sum_ab=0
        sum_a2=0
        sum_b2=0
        for j in range(0,168,1):
            sum_ab=sum_ab+df_ind_drama1[j]*df_ind1[j]
            sum_a2=sum_a2+(df_ind_drama1[j])**2
            sum_b2=sum_b2+(df_ind1[j])**2        
        grade_CB[i]=round(sum_ab/((sum_a2**0.5)*(sum_b2**0.5)),4)

grade_CB1=sorted(grade_CB.items(), key=lambda d: d[1], reverse=True)

CB={}
for i in grade_CB1:
    CB[i[0]]=i[1]

CB['G010075'] #根據CB演算法，使用者對G010075(dramaID)的可能評分
```




    0.5995



### 3.「協同過濾演算法」(User-baded CollaboratIve Filtering)的計算

### 3.1建立物品到用户的倒排表


```python
def movie_users_inverse_table(data):

    # build inverse table for item-users
    # key=movieID, value=list of userIDs who have seen this movie

    movie_users = dict()
    movie_popular = dict()

    for user, movies in data.items():
        for movie in movies:

            # inverse table for item-users
            if movie not in movie_users:
                movie_users[movie] = set()
            movie_users[movie].add(user)

            # count item popularity at the same time
            if movie not in movie_popular:
                movie_popular[movie] = 0
            movie_popular[movie] += 1
    print ('build movie-users inverse table succ', file=sys.stderr)

    return movie_users, movie_popular
```

### 3.2計算使用者共同收藏的戲劇個數


```python
def count_corated_items():
    
    # count co-rated items between users
    # key=userID value=dict of otherUserID with count of co-rated items
    movie_users, movie_popular = movie_users_inverse_table(data)
    
    users_corated_count=dict()

    for movie, users in movie_users.items():
        for u in users:
            users_corated_count.setdefault(u, defaultdict(int))
            for v in users:
                if u == v:
                    continue
                users_corated_count[u][v] += 1
    print ('build user co-rated movies matrix succ', file=sys.stderr)

    return users_corated_count
```

### 3.3建立使用者相似度矩陣


```python
def similarity_matrix(data):
   
    # calculate similarity matrix
    
    users_corated_count = count_corated_items()

    simMatrix=dict()

    simfactor_count = 0
    PRINT_STEP = 2000000

    for u, related_users in users_corated_count.items():
        simMatrix.setdefault(u, defaultdict(int))
        for v, count in related_users.items():
            simMatrix[u][v] = count / math.sqrt(
                len(data[u]) * len(data[v]))
            simfactor_count += 1
            if simfactor_count % PRINT_STEP == 0:
                print ('calculating user similarity factor(%d)' % simfactor_count, file=sys.stderr)

    print ('calculate user similarity matrix(similarity factor) succ', file=sys.stderr)
    print ('Total similarity factor number = %d' % simfactor_count, file=sys.stderr)

    return simMatrix
```

### 3.4 針對特定使用者，找出喜好最相近的前10人，計算其對每個戲劇的喜好程度


```python
def recommend(user_ip, data):
    
    simMatrix = similarity_matrix(data)
    
    rank=dict()
    watched_movies = data[user_ip]
    for similar_user, similarity_factor in sorted(simMatrix[user_ip].items(), key=itemgetter(1), reverse=True)[0:20]:
        for movie in data[similar_user]:
            if movie in watched_movies:
                continue
            rank.setdefault(movie, 0)
            rank[movie] += similarity_factor

    rank_sorted=sorted(rank.items(), key=itemgetter(1), reverse=True)

    return rank_sorted
```


```python
data=drama_dic_all
grade_CF=recommend('127.0.0.1', data)

CF={}
for i in grade_CF:
    CF[i[0]]=i[1]
    
CF['G010075'] #根據CF演算法，使用者對G010075(dramaID)的可能評分
```

    build movie-users inverse table succ
    build user co-rated movies matrix succ
    calculating user similarity factor(2000000)
    calculating user similarity factor(4000000)
    calculating user similarity factor(6000000)
    calculate user similarity matrix(similarity factor) succ
    Total similarity factor number = 7199428
    




    0.6708203932499369



## 4. 對CB及CF得到的分數進行加權平均，得到每個使用者的個人喜好分數


```python
mix={}

for key in CB:
    try:
        mix[key]=(CB[key]+CF[key]) 
    except:
        mix[key]=CB[key]

r_mix=sorted(mix.items(), key=lambda x:-x[1])

r_mix_dic={}

for i in r_mix:
    r_mix_dic[i[0]]=i[1]

r_mix_dic['G010075'] #CB及CF加權後， 使用者對G010075(dramaID)的喜好分數
```




    1.270320393249937



## 5. 利用個人喜好分數，搭配三種推薦策略，建構推薦清單

### 5.1 推薦策略一：利用使用者收藏清單判斷其偏好戲劇類型，將這些類型的戲劇抽取出來，利用個人喜好分數進行排序


```python
# 利用使用者過去的收藏清單判斷其偏好的戲劇類型

index_list=list(df_drama_zone_genre_actor_ind.mean(axis=0).index)[3:28]
grade_list=list(df_drama_zone_genre_actor_ind.mean(axis=0))[3:28]
ind_preference={}
for i in range(len(index_list)):
    ind_preference[index_list[i]]=grade_list[i]
genre_prefer=sorted(ind_preference.items(), key=lambda d: d[1], reverse=True)
genre_prefer[0:5]
```




    [('劇情', 1.0), ('喜劇', 0.25), ('奇幻', 0.125), ('歷史', 0.125), ('家庭', 0.125)]




```python
#將這些類型的戲劇抽取出來

df_Drama_prefer=df_Drama_GenreName[(df_Drama_GenreName['genreName']==genre_prefer[0][0]) \
                                   | (df_Drama_GenreName['genreName']==genre_prefer[1][0])\
                                   | (df_Drama_GenreName['genreName']==genre_prefer[2][0])\
                                   | (df_Drama_GenreName['genreName']==genre_prefer[3][0])]

df_Drama_prefer_list=df_Drama_prefer['dramaID'].tolist()
df_Drama_prefer_list[0:10]
```




    ['G010002',
     'G010003',
     'G010004',
     'G010005',
     'G010006',
     'G010007',
     'G010011',
     'G010012',
     'G010013',
     'G010015']




```python
#利用個人喜好分數進行排序, 但排除使用者已經收藏的戲劇

personal_rec={}
for i in df_Drama_prefer_list:
    try:
        personal_rec[i]=r_mix_dic[i]        
    except:
        pass
    
personal_rec1=sorted(personal_rec.items(), key=lambda x:-x[1])

drama_list_exclude=df_drama_zone_genre_actor_ind['dramaID'].tolist()

personal_rec1_list=[]
for i in personal_rec1:
    if i[0] in drama_list_exclude:
        pass
    else:
        personal_rec1_list.append(i[0])

personal_rec1_list[0:3]
```




    ['G030196', 'G010049', 'G010011']



### 5.2 推薦策略二：利用豆辨評分找出前100部評分最高的戲劇，將這些戲劇抽取出來，利用個人喜好分數進行排序


```python
#利用豆辨評分找出前100部評分最高的戲劇

pop=tbl_Drama.sort_values('hitto', ascending=False).head(100)
df_pop_prefer_list=pop['dramaID'].tolist()
df_pop_prefer_list[0:10]
```




    ['G010032',
     'G010033',
     'G030312',
     'G030167',
     'G030160',
     'G010152',
     'G020016',
     'G010012',
     'G020086',
     'G010234']




```python
#利用個人喜好分數進行排序, 但排除使用者已經收藏或是已出現在「推薦策略一」的戲劇

pop_rec={}
for i in df_pop_prefer_list:
    try:
        pop_rec[i]=r_mix_dic[i]        
    except:
        pass

pop_rec1=sorted(pop_rec.items(), key=lambda x:-x[1])

pop_rec1_list=[]
for i in pop_rec1:
    if i[0] in personal_rec1_list[0:4]+drama_list_exclude:
        pass
    else:
        pop_rec1_list.append(i[0])

pop_rec1_list[0:3]
```




    ['G010166', 'G010008', 'G020032']



### 5.3 推薦策略三：找出近6個月出版的新劇，將這些戲劇抽取出來，利用個人喜好分數進行排序


```python
#找出近6個月出版的新劇

latest=tbl_Drama.sort_values('publishTime', ascending=False).head(60)
df_latest_prefer_list=latest['dramaID'].tolist()
df_latest_prefer_list[0:10]
```




    ['G030096',
     'G030355',
     'G030353',
     'G030183',
     'G010169',
     'G010306',
     'G020128',
     'G030357',
     'G020131',
     'G030358']




```python
#利用個人喜好分數進行排序, 但排除使用者已經收藏或是已出現在「推薦策略一」及「推薦策略二」的戲劇

latest_rec={}
for i in df_latest_prefer_list:
    try:
        latest_rec[i]=r_mix_dic[i]        
    except:
        pass

latest_rec1=sorted(latest_rec.items(), key=lambda x:-x[1])

latest_rec1_list=[]
for i in latest_rec1:
    if i[0] in personal_rec1_list[0:4]+pop_rec1_list[0:4]+drama_list_exclude:
        pass
    else:
        latest_rec1_list.append(i[0])

latest_rec1_list[0:3]
```




    ['G030073', 'G010089', 'G020130']



### 5.4 推薦清單


```python
print(personal_rec1_list[0:4])
print(pop_rec1_list[0:4])
print(latest_rec1_list[0:4])
```

    ['G030196', 'G010049', 'G010011', 'G010162']
    ['G010166', 'G010008', 'G020032', 'G020095']
    ['G030073', 'G010089', 'G020130', 'G030259']
    
